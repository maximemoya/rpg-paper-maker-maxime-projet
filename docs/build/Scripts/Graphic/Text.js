/*
    RPG Paper Maker Copyright (C) 2017-2025 Wano

    RPG Paper Maker engine is under proprietary license.
    This source code is also copyrighted.

    Use Commercial edition for commercial use of your games.
    See RPG Paper Maker EULA here:
        http://rpg-paper-maker.com/index.php/eula.
*/
import { ALIGN, ALIGN_VERTICAL, Constants, Platform, ScreenResolution, Utils } from '../Common/index.js';
import { Data, Model } from '../index.js';
import { Stack } from '../Manager/index.js';
import { Base } from './Base.js';
/** @class
 *  A class for all the texts to display in HUD.
 *  @extends Bitmap
 *  @param {string} [text=""] - The brut text to display
 *  @param {Object} [opts={}] - Options
 *  @param {number} [opts.x=0] - The x coords of the text
 *  @param {number} [opts.y=0] - The y coords of the text
 *  @param {number} [opts.w=0] - The w coords of the text
 *  @param {number} [opts.h=0] - The h coords of the text
 *  @param {Align} [opts.align=ALIGN.LEFT] - Alignement of the text
 *  @param {number} [opts.fontSize=RPM.defaultValue(RPM.datasGame.System.dbOptions.vtSize, - RPM.fontSize)]
 *  The font height used for the text
 *  @param {string} [opts.fontName=RPM.defaultValue(RPM.datasGame.System.dbOptions.vtFont, - RPM.fontName)]
 *  The font name used for the text
 *  @param {ALIGN_VERTICAL} [opts.verticalAlign=ALIGN_VERTICAL.Center] - Vertical
 *  alignement of the text
 *  @param {SystemColor} [opts.color=RPM.defaultValue(RPM.datasGame.System.dbOptions.vtcText]
 *  The color used for the text
 *  @param {boolean} [opts.bold=false] - If checked, make the text bold
 *  @param {boolean} [opts.italic=false] - If checked, make the text italic
 *  @param {SystemColor} [opts.backColor=RPM.defaultValue(RPM.datasGame.System.dbOptions.vtcBackground, - null)]
 *  The background color behind the text
 *  @param {SystemColor} [opts.strokeColor=RPM.defaultValue(RPM.datasGame.System.dbOptions.tOutline, - false)? RPM.defaultValue(RPM.datasGame.System.dbOptions.vtcOutline, null) : null]
 *  The stroke color of the text
 */
class Text extends Base {
    constructor(text = '', { x = 0, y = 0, w = 0, h = 0, align = ALIGN.LEFT, fontSize = Utils.valueOrDefault(Data.Systems.dbOptions.v_tSize, Constants.DEFAULT_FONT_SIZE), fontName = Utils.valueOrDefault(Data.Systems.dbOptions.v_tFont, Constants.DEFAULT_FONT_NAME), verticalAlign = ALIGN_VERTICAL.CENTER, color = Utils.valueOrDefault(Data.Systems.dbOptions.v_tcText, Model.Color.WHITE), bold = false, italic = false, backColor = Utils.valueOrDefault(Data.Systems.dbOptions.v_tcBackground, null), strokeColor = Utils.valueOrDefault(Data.Systems.dbOptions.tOutline, false)
        ? Utils.valueOrDefault(Data.Systems.dbOptions.v_tcOutline, null)
        : null, } = {}) {
        super(x, y, w, h);
        this.lastW = 0;
        this.zoom = 1;
        this.align = align;
        this.fontName = fontName;
        this.verticalAlign = verticalAlign;
        this.color = color;
        this.bold = bold;
        this.italic = italic;
        this.backColor = backColor;
        this.strokeColor = strokeColor;
        this.setFontSize(fontSize);
        this.setText(Utils.valueOrDefault(text, ''));
    }
    wrapText(maxWidth) {
        const text = this.text.replace('\\n', '\n');
        const lines = text.split('\n');
        const words = [];
        let i, j, l, m, tempWords;
        for (i = 0, l = lines.length; i < l; i++) {
            tempWords = lines[i].split(' ');
            for (j = 0, m = tempWords.length; j < m; j++) {
                words.push(tempWords[j]);
            }
            if (i < l - 1) {
                words.push('\n');
            }
        }
        this.lines = [];
        let currentLine = words[0];
        for (let i = 1, l = words.length; i < l; i++) {
            const word = words[i];
            if (word === '\n') {
                this.lines.push(currentLine);
                currentLine = words[++i];
                continue;
            }
            const width = Platform.ctx.measureText(currentLine + ' ' + word).width + (this.strokeColor === null ? 0 : 2);
            if (width < maxWidth) {
                currentLine += ' ' + word;
            }
            else {
                this.lines.push(currentLine);
                currentLine = word;
            }
        }
        this.lines.push(currentLine);
        this.measureText();
    }
    /**
     *  Set the font size and the final font.
     *  @param {number} fontSize - The new font size
     */
    setFontSize(fontSize) {
        this.oFontSize = fontSize;
        this.fontSize = ScreenResolution.getScreenMinXY(fontSize);
        this.updateFont();
    }
    /**
     *  Set the final font.
     */
    updateFont() {
        this.font = Utils.createFont(this.fontSize, this.fontName, this.bold, this.italic);
    }
    /**
     *  Set the current displayed text.
     *  @param {string} text - The new text
     */
    setText(text) {
        text += ''; // Be sure that it's string type
        if (this.text !== text) {
            this.text = text;
            this.lines = this.text.split('\n');
            this.measureText();
            Stack.requestPaintHUD = true;
        }
    }
    /**
     *  Update the context font with resizing.
     */
    updateContextFont() {
        Platform.ctx.font = this.font;
    }
    /**
     *  Measure text width and stock results in the instance.
     */
    measureText() {
        this.updateContextFont();
        this.textWidth = 0;
        const l = this.lines.length;
        let size;
        for (let i = 0; i < l; i++) {
            size =
                Platform.ctx.measureText(this.lines[i]).width +
                    (this.strokeColor === null ? 0 : ScreenResolution.getScreenMinXY(2));
            if (size > this.textWidth) {
                this.textWidth = size;
            }
        }
        this.textHeight = this.fontSize * 2 * l;
    }
    /**
     *  Drawing the text in choice box.
     *  @param {number} [x=this.x] - The x position to draw graphic
     *  @param {number} [y=this.y] - The y position to draw graphic
     *  @param {number} [w=this.w] - The width dimention to draw graphic
     *  @param {number} [h=this.h] - The height dimention to draw graphic
     */
    drawChoice(x = this.x, y = this.y, w = this.w, h = this.h) {
        // Correcting x and y according to alignment
        let xBack = x;
        if (this.zoom !== 1) {
            this.fontSize *= this.zoom;
            this.updateFont();
            this.measureText();
        }
        // Wrap text if != 0
        if (this.lastW !== w && w !== 0) {
            this.lastW = w;
            this.updateContextFont();
            this.wrapText(w);
        }
        const textWidth = this.textWidth;
        const textHeight = this.fontSize + ScreenResolution.getScreenMinXY(this.strokeColor === null ? 0 : 2);
        switch (this.align) {
            case ALIGN.LEFT:
                x += ScreenResolution.getScreenMinXY(1);
                break;
            case ALIGN.RIGHT:
                x += w - ScreenResolution.getScreenMinXY(1);
                xBack = x - textWidth;
                break;
            case ALIGN.CENTER:
                x += w / 2;
                xBack = x - textWidth / 2;
                break;
        }
        switch (this.verticalAlign) {
            case ALIGN_VERTICAL.BOT:
                y += this.fontSize / 3 + h;
                break;
            case ALIGN_VERTICAL.TOP:
                y += this.fontSize;
                break;
            case ALIGN_VERTICAL.CENTER:
                y += this.fontSize / 3 + h / 2;
                break;
        }
        // Draw background color
        if (this.backColor !== null) {
            Platform.ctx.fillStyle = this.backColor.rgb;
            Platform.ctx.fillRect(xBack, y - textHeight, textWidth, textHeight);
        }
        // Set context options
        Platform.ctx.font = this.font;
        Platform.ctx.textAlign = this.align;
        const lineHeight = this.fontSize * 2;
        let i, l = this.lines.length;
        // Stroke text
        let yOffset;
        if (this.strokeColor !== null) {
            Platform.ctx.strokeStyle = this.strokeColor.rgb;
            yOffset = 0;
            for (i = 0; i < l; i++) {
                Platform.ctx.strokeText(this.lines[i], x - 1, y - 1 + yOffset);
                Platform.ctx.strokeText(this.lines[i], x - 1, y + 1 + yOffset);
                Platform.ctx.strokeText(this.lines[i], x + 1, y - 1 + yOffset);
                Platform.ctx.strokeText(this.lines[i], x + 1, y + 1 + yOffset);
                yOffset += lineHeight;
            }
        }
        // Drawing the text
        Platform.ctx.fillStyle = this.color.rgb;
        yOffset = 0;
        for (i = 0; i < l; i++) {
            Platform.ctx.fillText(this.lines[i], x, y + yOffset);
            yOffset += lineHeight;
        }
        // Fix font back
        if (this.zoom !== 1) {
            this.setFontSize(this.oFontSize);
            this.measureText();
        }
    }
    /**
     *  Drawing the text in box (duplicate of drawChoice).
     *  @param {number} [x=this.oX] - The x position to draw graphic
     *  @param {number} [y=this.oY] - The y position to draw graphic
     *  @param {number} [w=this.oW] - The width dimention to draw graphic
     *  @param {number} [h=this.oH] - The height dimention to draw graphic
     */
    draw(x = this.x, y = this.y, w = this.w, h = this.h) {
        this.drawChoice(x, y, w, h);
    }
}
export { Text };

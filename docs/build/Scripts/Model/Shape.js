/*
    RPG Paper Maker Copyright (C) 2017-2025 Wano

    RPG Paper Maker engine is under proprietary license.
    This source code is also copyrighted.

    Use Commercial edition for commercial use of your games.
    See RPG Paper Maker EULA here:
        http://rpg-paper-maker.com/index.php/eula.
*/
import * as THREE from 'three';
import { CUSTOM_SHAPE_KIND, Paths, Platform, Utils } from '../Common/index.js';
import { CustomGeometry } from '../Core/index.js';
import { Data, Manager } from '../index.js';
import { Base } from './Base.js';
/**
 * A custom shape of the game.
 */
export class Shape extends Base {
    constructor(json) {
        super(json);
        this.geometry = null;
    }
    /**
     * Get string extension of a custom shape kind.
     */
    static customShapeKindToString(kind) {
        switch (kind) {
            case CUSTOM_SHAPE_KIND.OBJ:
                return '.obj';
            case CUSTOM_SHAPE_KIND.MTL:
                return '.mtl';
            case CUSTOM_SHAPE_KIND.COLLISIONS:
                return '.obj collisions';
        }
        return '';
    }
    /**
     * Get the folder associated to a kind of custom shape.
     */
    static getFolder(kind, isBR, dlc) {
        return ((isBR ? Data.Systems.PATH_BR + '/' : dlc ? `${Data.Systems.PATH_DLCS}/${dlc}/` : Platform.ROOT_DIRECTORY) +
            this.getLocalFolder(kind));
    }
    /**
     * Get the local folder associated to a kind of custom shape.
     */
    static getLocalFolder(kind) {
        switch (kind) {
            case CUSTOM_SHAPE_KIND.OBJ:
                return Paths.OBJ;
            case CUSTOM_SHAPE_KIND.MTL:
                return Paths.MTL;
            case CUSTOM_SHAPE_KIND.COLLISIONS:
                return Paths.OBJ_COLLISIONS;
        }
        return '';
    }
    /**
     * Parse the .obj text into vertices, uvs, and bounds.
     */
    static parse(text) {
        const vertices = [];
        const uvs = [];
        const v = [];
        const t = [];
        let minVertex = new THREE.Vector3();
        let maxVertex = new THREE.Vector3();
        let firstVertex = true;
        const vertexPattern = /^v\s+([\d.+\-eE]+)\s+([\d.+\-eE]+)\s+([\d.+\-eE]+)/;
        const uvPattern = /^vt\s+([\d.+\-eE]+)\s+([\d.+\-eE]+)/;
        const facePattern = /^f\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))(?:\s+((-?\d+)\/(-?\d+)\/(-?\d+)))?/;
        for (const rawLine of text.split('\n')) {
            const line = rawLine.trim();
            if (!line || line.startsWith('#')) {
                continue;
            }
            let result;
            if ((result = vertexPattern.exec(line))) {
                // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
                const temp3D = new THREE.Vector3(parseFloat(result[1]) * Data.Systems.SQUARE_SIZE, parseFloat(result[2]) * Data.Systems.SQUARE_SIZE, parseFloat(result[3]) * Data.Systems.SQUARE_SIZE);
                v.push(temp3D);
                if (firstVertex) {
                    minVertex = temp3D.clone();
                    maxVertex = temp3D.clone();
                    firstVertex = false;
                }
                else {
                    minVertex.min(temp3D);
                    maxVertex.max(temp3D);
                }
            }
            else if ((result = uvPattern.exec(line))) {
                // ["vt 0.1 0.2", "0.1", "0.2"]
                t.push(new THREE.Vector2(parseFloat(result[1]), 1.0 - parseFloat(result[2])));
            }
            else if ((result = facePattern.exec(line))) {
                // ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]
                const parts = line.split(' ');
                for (let j = 1; j < parts.length - 2; j++) {
                    const arg1 = parts[1].split('/');
                    const arg2 = parts[1 + j].split('/');
                    const arg3 = parts[2 + j].split('/');
                    vertices.push(v[parseInt(arg1[0]) - 1]);
                    uvs.push(t[parseInt(arg1[1]) - 1]);
                    vertices.push(v[parseInt(arg2[0]) - 1]);
                    uvs.push(t[parseInt(arg2[1]) - 1]);
                    vertices.push(v[parseInt(arg3[0]) - 1]);
                    uvs.push(t[parseInt(arg3[1]) - 1]);
                }
            }
        }
        return {
            vertices,
            uvs,
            minVertex,
            maxVertex,
            center: new THREE.Vector3((maxVertex.x - minVertex.x) / 2 + minVertex.x, (maxVertex.y - minVertex.y) / 2 + minVertex.y, (maxVertex.z - minVertex.z) / 2 + minVertex.z),
            w: maxVertex.x - minVertex.x,
            h: maxVertex.y - minVertex.y,
            d: maxVertex.z - minVertex.z,
        };
    }
    /**
     *  Load the .obj.
     */
    async load() {
        if (this.id === -1 || this.geometry) {
            return;
        }
        if (this.base64) {
            const base64Data = this.base64.split(',')[1];
            this.geometry = Shape.parse(atob(base64Data));
            this.base64 = '';
        }
        else {
            const url = this.getPath();
            this.geometry = await new Promise((resolve) => {
                Shape.loader.load(url, (text) => resolve(Shape.parse(text)), () => { }, () => {
                    const error = `Could not load ${url}`;
                    if (Data.Systems.ignoreAssetsLoadingErrors) {
                        console.warn(error);
                        resolve({
                            vertices: [],
                            uvs: [],
                            minVertex: new THREE.Vector3(),
                            maxVertex: new THREE.Vector3(),
                            center: new THREE.Vector3(),
                            w: 0,
                            h: 0,
                            d: 0,
                        });
                    }
                    else {
                        Platform.showErrorMessage(error);
                    }
                });
            });
            const geometry = new CustomGeometry();
            const vertices = this.geometry.vertices;
            const uvs = this.geometry.uvs;
            let count = 0;
            for (let i = 0, l = this.geometry.vertices.length; i < l; i += 3) {
                geometry.pushTriangleVertices(vertices[i].clone(), vertices[i + 1].clone(), vertices[i + 2].clone());
                geometry.pushTriangleIndices(count);
                geometry.pushTriangleUVs(uvs[i].clone(), uvs[i + 1].clone(), uvs[i + 2].clone());
                count += 3;
            }
            geometry.updateAttributes();
            this.mesh = new THREE.Mesh(geometry, Manager.Collisions.BB_MATERIAL);
        }
    }
    /**
     * Get the absolute path of this shape.
     */
    getPath() {
        return this.id === -1 ? '' : `${Shape.getFolder(this.kind, this.isBR, this.dlc)}/${this.name}`;
    }
    /**
     * Load the shape as a base64 string when not on desktop and not br.
     */
    async checkBase64() {
        if (!Platform.IS_DESKTOP && !this.isBR && Platform.WEB_DEV) {
            this.base64 = await Platform.loadFile(`${Platform.ROOT_DIRECTORY.slice(0, -1)}${Shape.getLocalFolder(this.kind)}/${this.name}`);
        }
    }
    /**
     * Read the JSON associated with the shape.
     */
    read(json) {
        this.id = json.id;
        this.name = json.name;
        this.isBR = json.br;
        this.dlc = Utils.valueOrDefault(json.d, '');
        this.base64 = json.base64;
    }
}
Shape.loader = new THREE.FileLoader();

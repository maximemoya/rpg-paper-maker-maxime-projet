/*
    RPG Paper Maker Copyright (C) 2017-2025 Wano

    RPG Paper Maker engine is under proprietary license.
    This source code is also copyrighted.

    Use Commercial edition for commercial use of your games.
    See RPG Paper Maker EULA here:
        http://rpg-paper-maker.com/index.php/eula.
*/
import { ALIGN, CHARACTERISTIC_KIND, Interpreter, ITEM_KIND, ORIENTATION_WINDOW } from '../Common/index.js';
import { Game, Item, Player, Rectangle, WindowBox, WindowChoices } from '../Core/index.js';
import { Data, Graphic, Manager, Scene } from '../index.js';
import { MenuBase } from './MenuBase.js';
/**
 * The menu scene displaying heroes equipments
 *
 * @class MenuEquip
 * @extends {MenuBase}
 */
class MenuEquip extends MenuBase {
    constructor(title) {
        super();
        this.title = title;
        this.createAllWindows();
        this.updateForTab();
    }
    /**
     * create all the window in the scene.
     *
     * @memberof MenuEquip
     */
    createAllWindows() {
        this.createWindowTop();
        this.createWindowChoiceTabs();
        this.createWindowChoiceEquipment();
        this.createWindowChoiceList();
        this.createWindowInformation();
    }
    /**
     * create the top window
     *
     * @memberof MenuEquip
     */
    createWindowTop() {
        const rect = new Rectangle(20, 20, 200, 30);
        this.windowTop = new WindowBox(rect.x, rect.y, rect.width, rect.height, {
            content: new Graphic.Text(this.title, { align: ALIGN.CENTER }),
        });
    }
    /**
     * create the choice tab window
     *
     * @memberof MenuEquip
     */
    createWindowChoiceTabs() {
        const rect = new Rectangle(50, 60, 110, WindowBox.SMALL_SLOT_HEIGHT);
        const listHeroes = [];
        for (let i = 0; i < this.party().length; i++) {
            listHeroes[i] = new Graphic.PlayerDescription(this.party()[i]);
        }
        const options = {
            orientation: ORIENTATION_WINDOW.HORIZONTAL,
            nbItemMax: 4,
            padding: [0, 0, 0, 0],
        };
        this.windowChoicesTabs = new WindowChoices(rect.x, rect.y, rect.width, rect.height, listHeroes, options);
    }
    /**
     * create the equipment choice window
     *
     * @memberof MenuEquip
     */
    createWindowChoiceEquipment() {
        const rect = new Rectangle(20, 100, 290, WindowBox.SMALL_SLOT_HEIGHT);
        const nbEquipments = Data.BattleSystems.equipmentsIDs.length;
        const options = {
            nbItemsMax: Math.min(Scene.MenuEquip.MAX_SLOTS_EQUIPMENTS, nbEquipments),
        };
        this.windowChoicesEquipment = new WindowChoices(rect.x, rect.y, rect.width, rect.height, new Array(nbEquipments), options);
    }
    /**
     * create the choice window
     *
     * @memberof MenuEquip
     */
    createWindowChoiceList() {
        const nbEquips = Math.min(Scene.MenuEquip.MAX_SLOTS_EQUIPMENTS, Data.BattleSystems.equipmentsIDs.length);
        const nbEquipChoice = MenuBase.SLOTS_TO_DISPLAY - nbEquips - 1;
        const y = 100 + (nbEquips + 1) * WindowBox.SMALL_SLOT_HEIGHT;
        const rect = new Rectangle(20, y, 290, WindowBox.SMALL_SLOT_HEIGHT);
        this.windowChoicesList = new WindowChoices(rect.x, rect.y, rect.width, rect.height, [], {
            nbItemsMax: nbEquipChoice,
            currentSelectedIndex: -1,
        });
    }
    /**
     * create the information window
     *
     * @memberof MenuEquip
     */
    createWindowInformation() {
        const rect = new Rectangle(330, 100, 285, 350);
        this.windowInformation = new WindowBox(rect.x, rect.y, rect.width, rect.height, {
            padding: WindowBox.SMALL_PADDING_BOX,
        });
    }
    /**
     * update the tab window
     *
     * @memberof MenuEquip
     */
    updateForTab() {
        // update equipment
        const equipLength = Player.getEquipmentLength();
        const l = Data.BattleSystems.equipmentsIDs.length;
        const player = Game.current.teamHeroes[this.windowChoicesTabs.currentSelectedIndex];
        const characteristics = player.getCharacteristics();
        const list = new Array(l);
        let j, m, characteristic, isPossible;
        for (let i = 0; i < l; i++) {
            // Check if is possible because of characteristics
            isPossible = true;
            for (j = 0, m = characteristics.length; j < m; j++) {
                characteristic = characteristics[j];
                if (characteristic.kind === CHARACTERISTIC_KIND.ALLOW_FORBID_CHANGE &&
                    characteristic.changeEquipmentID.getValue() === Data.BattleSystems.equipmentsIDs[i]) {
                    isPossible = characteristic.isAllowChangeEquipment;
                }
            }
            list[i] = new Graphic.Equip(player, Data.BattleSystems.equipmentsIDs[i], equipLength, isPossible);
        }
        this.windowChoicesEquipment.setContents(list);
        this.selectedEquipment = -1;
        this.windowChoicesList.unselect();
        this.updateEquipmentList();
        this.updateInformations();
    }
    /**
     * update the equipment list
     *
     * @memberof MenuEquip
     */
    updateEquipmentList() {
        const currentIndex = this.windowChoicesEquipment.currentSelectedIndex;
        const idEquipment = Data.BattleSystems.equipmentsIDs[currentIndex];
        const list = [new Graphic.Text('  [' + Data.Languages.extras.remove.name() + ']')];
        let item, systemItem;
        let type, nbItem;
        const player = Game.current.teamHeroes[this.windowChoicesTabs.currentSelectedIndex];
        let j, m, characteristic, allow, characteristics;
        for (let i = 0, l = Game.current.items.length; i < l; i++) {
            item = Game.current.items[i];
            if (item.kind !== ITEM_KIND.ITEM) {
                systemItem = item.system;
                type = systemItem.getType();
                if (type.equipments[idEquipment]) {
                    nbItem = item.nb;
                    if (nbItem > 0) {
                        allow = player.canEquipWeaponArmor(item);
                        if (allow &&
                            Interpreter.evaluate(systemItem.conditionFormula.getValue(), {
                                user: Game.current.teamHeroes[this.windowChoicesTabs.currentSelectedIndex],
                            })) {
                            list.push(new Graphic.Item(item, { nbItem: nbItem }));
                        }
                    }
                }
            }
        }
        this.windowChoicesList.setContentsCallbacks(list, null, -1);
    }
    /**
     * update the equipment stats display information.
     *
     * @memberof MenuEquip
     */
    updateInformations() {
        const player = Game.current.teamHeroes[this.windowChoicesTabs.currentSelectedIndex];
        if (this.selectedEquipment === -1) {
            this.list = [];
        }
        else {
            const item = this.windowChoicesList.getCurrentContent();
            const equipmentID = Data.BattleSystems.equipmentsIDs[this.windowChoicesEquipment.currentSelectedIndex];
            const system = item.item ? item.item.system : null;
            const result = player.getEquipmentStatsAndBonus(system, equipmentID);
            this.list = result[0];
            this.bonus = result[1];
        }
        this.windowInformation.content = new Graphic.EquipStats(player, this.list);
    }
    /**
     *  Move tab according to key.
     *  @param {boolean} isKey
     *  @param {{ key?: string, x?: number, y?: number }} [options={}]
     */
    moveTabKey(isKey, options = {}) {
        // Tab
        const indexTab = this.windowChoicesTabs.currentSelectedIndex;
        if (isKey) {
            this.windowChoicesTabs.onKeyPressedAndRepeat(options.key);
        }
        else {
            this.windowChoicesTabs.onMouseMove(options.x, options.y);
        }
        if (indexTab !== this.windowChoicesTabs.currentSelectedIndex) {
            this.updateForTab();
        }
        // Equipment
        if (this.selectedEquipment === -1) {
            const indexEquipment = this.windowChoicesEquipment.currentSelectedIndex;
            if (isKey) {
                this.windowChoicesEquipment.onKeyPressedAndRepeat(options.key);
            }
            else {
                this.windowChoicesEquipment.onMouseMove(options.x, options.y);
            }
            if (indexEquipment !== this.windowChoicesEquipment.currentSelectedIndex) {
                this.updateEquipmentList();
            }
        }
        else {
            const indexList = this.windowChoicesList.currentSelectedIndex;
            if (isKey) {
                this.windowChoicesList.onKeyPressedAndRepeat(options.key);
            }
            else {
                this.windowChoicesList.onMouseMove(options.x, options.y);
            }
            if (indexList !== this.windowChoicesList.currentSelectedIndex) {
                this.updateInformations();
            }
        }
    }
    /**
     *  Remove the selected equipment.
     */
    remove() {
        this.removeAnEquipment(Data.BattleSystems.equipmentsIDs[this.windowChoicesEquipment.currentSelectedIndex]);
    }
    /**
     *  Remove an equipment according to ID.
     *  @param {number} id
     */
    removeAnEquipment(id) {
        const player = this.party()[this.windowChoicesTabs.currentSelectedIndex];
        const prev = player.equip[id];
        player.equip[id] = null;
        if (prev) {
            const item = Item.findItem(prev.kind, prev.system.id);
            if (item === null) {
                prev.add(1);
            }
            else {
                item.add(1);
            }
        }
        this.updateStats();
    }
    /**
     *  Equip the selected equipment.
     */
    equip() {
        const index = this.windowChoicesTabs.currentSelectedIndex;
        const character = Game.current.teamHeroes[index];
        const gameItem = this.windowChoicesList.getCurrentContent().item;
        const id = Data.BattleSystems.equipmentsIDs[this.windowChoicesEquipment.currentSelectedIndex];
        const prev = character.equip[id];
        character.equip[id] = gameItem;
        // If "don't allow weapon/armor" characteristic now active, remove equipment
        for (const characteristic of gameItem.system.characteristics) {
            if (characteristic.kind === CHARACTERISTIC_KIND.ALLOW_FORBID_EQUIP && !characteristic.isAllowEquip) {
                const weaponArmor = characteristic.isAllowEquipWeapon
                    ? Data.BattleSystems.getWeaponKind(characteristic.equipWeaponTypeID.getValue())
                    : Data.BattleSystems.getArmorKind(characteristic.equipArmorTypeID.getValue());
                for (const [id, equipment] of weaponArmor.equipments.entries()) {
                    if (equipment) {
                        this.removeAnEquipment(id);
                    }
                }
            }
        }
        // Remove one equip from inventory
        let item;
        for (let i = 0, l = Game.current.items.length; i < l; i++) {
            item = Game.current.items[i];
            if (item.kind === gameItem.kind && item.system.id === gameItem.system.id) {
                item.remove(1);
                break;
            }
        }
        if (prev) {
            const item = Item.findItem(prev.kind, prev.system.id);
            if (item === null) {
                prev.add(1);
            }
            else {
                item.add(1);
            }
        }
        this.updateStats();
    }
    /**
     * update the character stats
     *
     * @memberof MenuEquip
     */
    updateStats() {
        const index = this.windowChoicesTabs.currentSelectedIndex;
        this.party()[index].updateEquipmentStats(this.list, this.bonus);
    }
    /**
     *  A scene action.
     *  @param {boolean} isKey
     *  @param {{ key?: string, x?: number, y?: number }} [options={}]
     */
    action(isKey, options = {}) {
        if (this.selectedEquipment === -1) {
            if (Scene.MenuBase.checkCancelMenu(isKey, options)) {
                Data.Systems.soundCancel.playSound();
                Manager.Stack.pop();
            }
            else if (Scene.MenuBase.checkActionMenu(isKey, options)) {
                if (this.windowChoicesEquipment.getCurrentContent().isPossible) {
                    Data.Systems.soundConfirmation.playSound();
                    this.selectedEquipment = this.windowChoicesEquipment.currentSelectedIndex;
                    this.windowChoicesList.currentSelectedIndex = 0;
                    if (this.windowChoicesList.listContents.length > 1) {
                        this.windowChoicesList.goDown();
                    }
                    this.updateInformations();
                    this.windowChoicesList.selectCurrent();
                }
                else {
                    Data.Systems.soundCancel.playSound();
                }
            }
        }
        else {
            if (Scene.MenuBase.checkCancelMenu(isKey, options)) {
                Data.Systems.soundCancel.playSound();
                this.selectedEquipment = -1;
                this.windowChoicesList.unselect();
                this.updateInformations();
            }
            else if (Scene.MenuBase.checkActionMenu(isKey, options)) {
                if (this.windowChoicesList.getCurrentContent() !== null) {
                    Data.Systems.soundConfirmation.playSound();
                    if (this.windowChoicesList.currentSelectedIndex === 0) {
                        this.remove();
                    }
                    else {
                        this.equip();
                    }
                    this.selectedEquipment = -1;
                    this.windowChoicesList.unselect();
                    this.updateForTab();
                }
                else {
                    Data.Systems.soundImpossible.playSound();
                }
            }
        }
    }
    /**
     *  A scene move.
     *  @param {boolean} isKey
     *  @param {{ key?: string, x?: number, y?: number }} [options={}]
     */
    move(isKey, options = {}) {
        this.moveTabKey(isKey, options);
    }
    /**
     *  Update the scene.
     */
    update() {
        Scene.Base.prototype.update.call(Scene.Map.current);
        this.windowChoicesTabs.update();
        this.windowChoicesEquipment.update();
        this.windowChoicesList.update();
    }
    /**
     *  Handle scene key pressed.
     *  @param {number} key - The key ID
     */
    onKeyPressed(key) {
        Scene.Base.prototype.onKeyPressed.call(Scene.Map.current, key);
        this.action(true, { key: key });
    }
    /**
     *  Handle scene key released.
     *  @param {number} key - The key ID
     */
    onKeyReleased(key) {
        Scene.Base.prototype.onKeyReleased.call(Scene.Map.current, key);
    }
    /**
     *  Handle scene pressed repeat key.
     *  @param {number} key - The key ID
     *  @returns {boolean}
     */
    onKeyPressedRepeat(key) {
        return super.onKeyPressedAndRepeat(key);
    }
    /**
     *  Handle scene pressed and repeat key.
     *  @param {number} key - The key ID
     *  @returns {boolean}
     */
    onKeyPressedAndRepeat(key) {
        const res = Scene.Base.prototype.onKeyPressedAndRepeat.call(Scene.Map.current, key);
        this.move(true, { key: key });
        return res;
    }
    /**
     *  @inheritdoc
     */
    onMouseMove(x, y) {
        super.onMouseMove(x, y);
        this.move(false, { x: x, y: y });
    }
    /**
     *  @inheritdoc
     */
    onMouseUp(x, y) {
        super.onMouseUp(x, y);
        this.action(false, { x: x, y: y });
    }
    /**
     *  Draw the HUD scene.
     */
    drawHUD() {
        // Draw the local map behind
        Scene.Map.current.drawHUD();
        // Draw the menu
        this.windowTop.draw();
        this.windowChoicesTabs.draw();
        this.windowChoicesEquipment.draw();
        this.windowChoicesList.draw();
        this.windowInformation.draw();
        // Draw interpreters
        super.drawHUD();
    }
}
MenuEquip.MAX_SLOTS_EQUIPMENTS = 7;
export { MenuEquip };
